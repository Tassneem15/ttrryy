//final code between user and AI with 1 v 1 option #include <iostream> using namespace std; const int EMPTY = 0 ; // Structure to represent a move struct Move { int row, col; }; // Function to check if there are any moves left on the board bool isMovesLeft(char board[3][3]) { for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j) if (board[i][j] == '_') return true; return false; } // Evaluation function to determine the score of the board int evaluate(char b[3][3], char player, char opponent) { // Check rows and columns for (int row = 0; row < 3; ++row) { if (b[row][0] == b[row][1] && b[row][1] == b[row][2]) { if (b[row][0] == player) return +10; else if (b[row][0] == opponent) return -10; } } for (int col = 0; col < 3; ++col) { if (b[0][col] == b[1][col] && b[1][col] == b[2][col]) { if (b[0][col] == player) return +10; else if (b[0][col] == opponent) return -10; } } // Check diagonals if (b[0][0] == b[1][1] && b[1][1] == b[2][2]) { if (b[0][0] == player) return +10; else if (b[0][0] == opponent) return -10; } if (b[0][2] == b[1][1] && b[1][1] == b[2][0]) { if (b[0][2] == player) return +10; else if (b[0][2] == opponent) return -10; } return 0; // No winner } // Minimax function with alpha-beta pruning int minimax(char board[3][3], int depth, int alpha, int beta, bool isMax, char player, char opponent) { int score = evaluate(board, player, opponent); if (score == 10 || score == -10 || !isMovesLeft(board)) return score; if (isMax) { int best = -1000; for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { if (board[i][j] == '_') { board[i][j] = player; best = max(best, minimax(board, depth + 1, alpha, beta, !isMax, player, opponent)); alpha = max(alpha, best); board[i][j] = '_'; if (beta <= alpha) break; } } } return best; } else { int best = 1000; for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { if (board[i][j] == '_') { board[i][j] = opponent; best = min(best, minimax(board, depth + 1, alpha, beta, !isMax, player, opponent)); beta = min(beta, best); board[i][j] = '_'; if (beta <= alpha) break; } } } return best; } } // Function to find the best move using the minimax algorithm Move findBestMove(char board[3][3], char player, char opponent) { int bestVal = -1000; Move bestMove; bestMove.row = -1; bestMove.col = -1; for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { if (board[i][j] == '_') { board[i][j] = player; int moveVal = minimax(board, 0, -1000, 1000, false, player, opponent); board[i][j] = '_'; if (moveVal > bestVal) { bestVal = moveVal; bestMove.row = i; bestMove.col = j; } } } } return bestMove; } void drawBoard(char board[3][3]) { cout << "-------------\n"; for (int i = 0; i < 3; i++) { cout << "| "; for (int j = 0; j < 3; j++) { cout << board[i][j] << " | "; } cout << "\n-------------\n"; } } template <typename T > bool gameOver(T Board) { // Check rows and columns for (int i = 0; i < 3; ++i) { if (Board[i][0] != '_' && Board[i][0] == Board[i][1] && Board[i][1] == Board[i][2]) { return true; } if (Board[0][i] != '_' && Board[0][i] == Board[1][i] && Board[1][i] == Board[2][i]) { return true; } } // Check diagonals if (Board[0][0] != '_' && Board [0][0] == Board [1][1] && Board [1][1] == Board [2][2]) { return true; } if (Board[0][2] != '_' && Board[0][2] == Board[1][1] && Board [1][1] == Board[2][0]) { return true; } // Check for draw for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { if (Board[i][j] == '_') { return false; } } } return true; } bool checkDraw(char board[3][3]) { for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { if (board[i][j] == '_') { return false; } } } return true; } int main() { char board[3][3] = { {'_', '_', '_'}, {'_', '_', '_'}, {'_', '_', '_'} }; char player ; char opponent ; bool playerTurn = false; int start ; int AI ; cout << "Select the game mode:\nenter 1 for user vs AI\nenter 0 for 1 vs 1: "; cin>> AI ; if (AI) // choose between two modes { cout << "If you want to start playing, press 1,\nand if you want the computer to start, press 0 " <<endl ; cin >> start ; cout << "choose your symbol Please, X or O"<< endl ; cin>>opponent ; if(opponent == 'X' || opponent == 'x') player = 'O'; else if (opponent == 'O' || opponent == 'o') player = 'X'; if(start) {playerTurn = true ; drawBoard(board) ; } while (!gameOver(board)) { if (playerTurn) { // Player's turn cout << "your turn (symbol: " << opponent << ")\n"; Move opponentrMove; cout << "Enter row and column (1-3): "; cin >> opponentrMove.row >>opponentrMove.col; --opponentrMove.row; --opponentrMove.col; if (board[opponentrMove.row][opponentrMove.col] != '_') { cout << "Invalid move! Please select an empty cell.\n"; continue; } board[opponentrMove.row][opponentrMove.col] = opponent; } else { // player's turn (controlled by AI) cout << "AI's turn (symbol: " << player << ")\n"; Move bestMove = findBestMove(board, player, opponent ); board[bestMove.row][bestMove.col] = player; } // Draw the board drawBoard(board); // Switch turns playerTurn = !playerTurn; } // Game over, determine the result if (evaluate(board, player, opponent) == 10) { cout << "Player " << player << " wins!" << endl; } else if (evaluate(board, player, opponent) == -10) { cout << "Player " << opponent << " wins!" << endl; } else { cout << "It's a draw!" << endl; } } else { char currentPlayer = 'X'; //bool gameWon = false; while (!gameOver(board)) { drawBoard(board); Move playerMove; cout << "Player " << currentPlayer << ", enter row and column (1-3): "; cin >> playerMove.row >> playerMove.col; playerMove.row--; playerMove.col--; if (board[playerMove.row][playerMove.col] != '_') { cout << "Invalid move! Try again." << endl; continue; } board[playerMove.row][playerMove.col] = currentPlayer; if (gameOver(board) && !checkDraw(board)) { drawBoard(board) ; cout << "Player " << currentPlayer << " wins!" << endl; //gameWon = true; } currentPlayer = (currentPlayer == 'X') ? 'O' : 'X'; // Switch turns } if (checkDraw(board)) { drawBoard(board) ; cout << "It's a draw!" << endl; } } return 0; }
